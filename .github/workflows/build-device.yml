# Builds device.
# Build is performed on all supported OS versions.
name: Build Device

on:
  workflow_dispatch:
    inputs:
      timeout:
        required: true
        description: 'The timeout for the job in minutes'
        type: number
        default: 15
  pull_request:
  push:
    branches: ["main"]

env:
  TT_UMD_DIR: tt-umd
  # Note that $GITHUB_WORKSPACE can only be used in the shell step.
  TT_UMD_DIR_SHELL: $GITHUB_WORKSPACE/tt-umd
  CLIENTS_BUILD_DIR_SHELL: $GITHUB_WORKSPACE/build_clients
  BUILD_OUTPUT_DIR: ./build
  LIB_OUTPUT_DIR: ./build/lib
  DEPS_OUTPUT_DIR: ./build/_deps
  TEST_OUTPUT_DIR: ./build/test
  CREATE_MAP_BINARIES_DIR: ./device/bin/silicon
  INSTALL_OUTPUT_DIR: ./install
  WHEEL_OUTPUT_DIR: ./build/wheel

jobs:
  build:
    # Due to parsing bug, fromJSON is used to convert string to number.
    # In pull_request or push events, the input context is not available, stating the default again here.
    timeout-minutes: ${{ fromJSON(inputs.timeout || '15') }}
    strategy:
      fail-fast: false
      matrix:
        image: [
          {container-distro: ubuntu-22.04, compiler: clang, c: clang-13, cpp: clang++-13},
          {container-distro: ubuntu-22.04, compiler: clang, c: clang-20, cpp: clang++-20},
          {container-distro: ubuntu-22.04, compiler: gcc, c: gcc-11, cpp: g++-11},
          # Note: We're intentionally skipping clang-13 which is obsolete on Ubuntu 24.04.
          {container-distro: ubuntu-24.04, compiler: clang, c: clang-20, cpp: clang++-20},
          {container-distro: ubuntu-24.04, compiler: gcc, c: gcc-11, cpp: g++-11},
          {container-distro: fedora-39, compiler: gcc, c: gcc, cpp: g++},
        ]

    name: Build device for any arch on ${{ matrix.image.container-distro }} with ${{ matrix.image.compiler }}
    runs-on: tt-ubuntu-2204-large-stable
    container:
      image: >-
        harbor.ci.tenstorrent.net/ghcr.io/${{ github.repository }}/tt-umd-ci-${{
        matrix.image.container-distro }}:latest
    env:
      ARTIFACT_DISTRO_VER: ${{ matrix.image.container-distro }}
      ARTIFACT_COMPILER: ${{ matrix.image.compiler }}

    steps:
      - uses: actions/checkout@v4
        with:
          # Clone under tt-umd directory
          path: ${{ env.TT_UMD_DIR }}
          submodules: recursive

      - name: Select Compiler
        run: |
          echo "CC=${{ matrix.image.c }}" >> $GITHUB_ENV
          echo "CXX=${{ matrix.image.cpp }}" >> $GITHUB_ENV

      # Build with all components to verify the build passes.
      - name: Build All
        run: |
          cd ${{ env.TT_UMD_DIR_SHELL }}
          echo "Compiling the code..."
          cmake -B ${{ env.BUILD_OUTPUT_DIR }} -G Ninja \
            -DTT_UMD_BUILD_ALL=ON \
            -DTT_UMD_BUILD_PIP=ON \
            -DTT_UMD_ENABLE_CLANG_TIDY=ON
          cmake --build ${{ env.BUILD_OUTPUT_DIR }}
          echo "Compile complete."

      # Upload compile_commands.json for debugging and IDE integration.
      # This file contains exact compilation flags used during the build,
      # enabling developers to reproduce the analysis locally and troubleshoot issues.
      - name: Upload compile commands
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: >
            clang-tidy-compile-commands-${{ matrix.image.container-distro }}-${{ matrix.image.c }}
          path: ${{ env.TT_UMD_DIR }}/build/compile_commands.json

      - name: Prepare clang-tidy config file for upload
        run: |
          chmod a+r ${{ env.TT_UMD_DIR }}/.clang-tidy
          cp ${{ env.TT_UMD_DIR }}/.clang-tidy $RUNNER_TEMP/clang-tidy-build-config

      # Upload clang-tidy configuration files to show exactly which checks were enabled/disabled.
      # Provides transparency and allows developers to use the same settings locally
      # for consistent static analysis results.
      - name: Upload clang-tidy config
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: >
            clang-tidy-config-${{ matrix.image.container-distro }}-${{ matrix.image.c }}
          path: ${{ runner.temp }}/clang-tidy-build-config

      - name: Generate .deb package
        if: ${{ contains(matrix.image.container-distro, 'ubuntu-') }}
        working-directory: ${{ env.TT_UMD_DIR }}/build
        run: |
          cpack -G DEB

      - name: Generate .rpm package
        if: ${{ contains(matrix.image.container-distro, 'fedora-') }}
        working-directory: ${{ env.TT_UMD_DIR }}/build
        run: |
          cpack -G RPM

      - name: Upload DEB dev and runtime packages
        if: ${{ contains(matrix.image.container-distro, 'ubuntu-') }}
        uses: actions/upload-artifact@v4
        with:
          name: tt-umd-packages-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: |
            ${{ env.TT_UMD_DIR }}/build/*.deb
          if-no-files-found: error

      - name: Upload RPM dev and runtime packages
        if: ${{ contains(matrix.image.container-distro, 'fedora-') }}
        uses: actions/upload-artifact@v4
        with:
          name: tt-umd-packages-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: |
            ${{ env.TT_UMD_DIR }}/build/*.rpm
          if-no-files-found: error

      - name: Upload example config files
        uses: actions/upload-artifact@v4
        with:
          name: tt-umd-examples-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: |
            ${{ env.TT_UMD_DIR }}/cmake/example_client.cmake
            ${{ env.TT_UMD_DIR }}/cmake/CPM.cmake
          if-no-files-found: error

      - name: Install device library
        run: |
          cd ${{ env.TT_UMD_DIR_SHELL }}
          echo "Installing device library..."
          cmake --install ${{ env.BUILD_OUTPUT_DIR }} --prefix ${{ env.INSTALL_OUTPUT_DIR }}
          echo "Install complete."

      - name: Prepare and isolate install artifacts
        run: |
          echo "Preparing and isolating install artifacts..."
          mkdir ${{ env.CLIENTS_BUILD_DIR_SHELL }}
          cd ${{ env.CLIENTS_BUILD_DIR_SHELL }}
          echo "Copying install artifacts..."
          cp -r ${{ env.TT_UMD_DIR_SHELL }}/${{ env.INSTALL_OUTPUT_DIR }} \
             ${{ env.CLIENTS_BUILD_DIR_SHELL }}/umd_install
          echo "Copying cmake example config file..."
          mkdir -p ${{ env.CLIENTS_BUILD_DIR_SHELL }}/cmake
          cp ${{ env.TT_UMD_DIR_SHELL }}/cmake/example_client.cmake \
             ${{ env.CLIENTS_BUILD_DIR_SHELL }}/cmake/example_client.cmake
          cp ${{ env.TT_UMD_DIR_SHELL }}/cmake/CPM.cmake ${{ env.CLIENTS_BUILD_DIR_SHELL }}/cmake/CPM.cmake
          echo "Copying components to build..."
          cp -r ${{ env.TT_UMD_DIR_SHELL }}/examples ${{ env.CLIENTS_BUILD_DIR_SHELL }}/examples
          cp -r ${{ env.TT_UMD_DIR_SHELL }}/nanobind ${{ env.CLIENTS_BUILD_DIR_SHELL }}/nanobind
          cp -r ${{ env.TT_UMD_DIR_SHELL }}/tools ${{ env.CLIENTS_BUILD_DIR_SHELL }}/tools
          echo "Preparation complete."
          pwd
          ls -laR ${{ env.CLIENTS_BUILD_DIR_SHELL }}

      - name: Build examples as standalone
        run: |
          cd ${{ env.CLIENTS_BUILD_DIR_SHELL }}/examples
          cmake -B build -G Ninja -DCMAKE_PREFIX_PATH=../umd_install
          cmake --build build

      - name: Build nanobind as standalone
        run: |
          cd ${{ env.CLIENTS_BUILD_DIR_SHELL }}/nanobind
          cmake -B build -G Ninja -DCMAKE_PREFIX_PATH=../umd_install
          cmake --build build

      - name: Build tools as standalone
        run: |
          cd ${{ env.CLIENTS_BUILD_DIR_SHELL }}/tools
          cmake -B build -G Ninja -DCMAKE_PREFIX_PATH=../umd_install
          cmake --build build

      - name: Rebuild package for python without wheel
        run: |
          cd ${{ env.TT_UMD_DIR_SHELL }}
          echo "Recompiling the code..."
          cmake -B ${{ env.BUILD_OUTPUT_DIR }} -G Ninja \
            -DTT_UMD_BUILD_ALL=ON \
            -DTT_UMD_BUILD_PIP=OFF \
            -DENABLE_CLANG_TIDY=ON
          cmake --build ${{ env.BUILD_OUTPUT_DIR }}
          echo "Compile complete."

      - name: Generate .deb package for umd-python
        if: ${{ contains(matrix.image.container-distro, 'ubuntu-') }}
        working-directory: ${{ env.TT_UMD_DIR }}/build
        run: |
          cpack -G DEB

      - name: Upload .deb packages for umd-python
        if: ${{ contains(matrix.image.container-distro, 'ubuntu-') }}
        uses: actions/upload-artifact@v4
        with:
          name: tt-umd-python-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: |
            ${{ env.TT_UMD_DIR }}/build/*umd-python*.deb
          if-no-files-found: error

      - name: Generate .rpm package for umd-python
        if: ${{ contains(matrix.image.container-distro, 'fedora-') }}
        working-directory: ${{ env.TT_UMD_DIR }}/build
        run: |
          cpack -G RPM

      - name: Upload .rpm packages for umd-python
        if: ${{ contains(matrix.image.container-distro, 'fedora-') }}
        uses: actions/upload-artifact@v4
        with:
          name: tt-umd-python-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: |
            ${{ env.TT_UMD_DIR }}/build/*umd-python*.rpm
          if-no-files-found: error

  build-manylinux-wheels:
    # Due to parsing bug, fromJSON is used to convert string to number.
    # In pull_request or push events, the input context is not available, stating the default again here.
    timeout-minutes: ${{ fromJSON(inputs.timeout || '15') }}

    name: Build umd manylinux wheel
    runs-on: tt-ubuntu-2204-large-stable

    steps:
      - uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install cibuildwheel
        run: python -m pip install cibuildwheel

      - name: Build manylinux wheels
        shell: bash
        env:
          # Use custom manylinux Docker image with all dependencies pre-installed
          CIBW_MANYLINUX_X86_64_IMAGE: ghcr.io/tenstorrent/tt-umd/tt-umd-ci-manylinux:latest
          # This command will be executed for each wheel build to verify that the wheel is functional.
          CIBW_TEST_COMMAND: 'python -c "import tt_umd"'
        run: |
          echo "Cleaning up wheel directory in case of previous build..."
          rm -rf ${{ env.WHEEL_OUTPUT_DIR }}
          mkdir -p ${{ env.WHEEL_OUTPUT_DIR }}
          echo "Building manylinux wheel..."
          python -m cibuildwheel --output-dir ${{ env.WHEEL_OUTPUT_DIR }}
          echo "Build complete."

      - name: Upload wheels as artifacts
        uses: actions/upload-artifact@v4
        with:
          name: manylinux-wheel-artifact
          path: |
            ${{ env.WHEEL_OUTPUT_DIR }}

  test-packages:
    needs: build
    timeout-minutes: ${{ fromJSON(inputs.timeout || '15') }}
    strategy:
      fail-fast: false
      matrix:
        build: [
          {os: ubuntu-22.04, compiler: gcc},
          {os: ubuntu-24.04, compiler: gcc}
        ]
        pkg: [
          {package: deb, distro: ubuntu},
          {package: rpm, distro: fedora}
        ]

    name: >-
      Test ${{ matrix.pkg.package }} package on ${{ matrix.pkg.distro }} distro
      (which was generated via
      ${{ (matrix.pkg.package == 'rpm' && 'tt-umd-ci-fedora-39')
      || format('tt-umd-ci-{0}', matrix.build.os) }}-${{
      (matrix.pkg.package == 'rpm' && 'gcc') || matrix.build.compiler }})
    runs-on: ubuntu-22.04
    container:
      image: >-
        ${{ matrix.pkg.package == 'rpm' && format('ghcr.io/{0}/tt-umd-ci-fedora-39:latest', github.repository)
        || format('ghcr.io/{0}/tt-umd-ci-{1}:latest', github.repository, matrix.build.os) }}

    env:
      ARTIFACT_DISTRO_VER: >-
        ${{ (matrix.pkg.package == 'rpm' && 'fedora-39') || matrix.build.os }}
      ARTIFACT_COMPILER: >-
        ${{ (matrix.pkg.package == 'rpm' && 'gcc') || matrix.build.compiler }}
    steps:
      - uses: actions/checkout@v4
        with:
          path: tt-umd
          submodules: recursive
      - name: Download Packages Artifact
        uses: actions/download-artifact@v4
        with:
          name: tt-umd-packages-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: >-
            ./downloaded-artifact/tt-umd-packages-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}-package

      - name: Download Examples Artifact
        uses: actions/download-artifact@v4
        with:
          name: tt-umd-examples-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: >-
            ./downloaded-artifact/tt-umd-examples-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}-example

      - name: Download Python Packages Artifact
        uses: actions/download-artifact@v4
        continue-on-error: true
        with:
          name: tt-umd-python-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}
          path: >-
            ./downloaded-artifact/tt-umd-python-${{ env.ARTIFACT_DISTRO_VER }}-${{ env.ARTIFACT_COMPILER }}-package

      - name: Run test on example and python with packages
        shell: bash
        run: |
          set -euo pipefail
          PKG_FMT="${{ matrix.pkg.package }}"
          DISTRO_VER="${{ env.ARTIFACT_DISTRO_VER }}"
          COMP="${{ env.ARTIFACT_COMPILER }}"

          # Directories from downloaded artifacts
          PACKAGE_DIR="./downloaded-artifact/tt-umd-packages-${DISTRO_VER}-${COMP}-package"
          PY_PACKAGE_DIR="./downloaded-artifact/tt-umd-python-${DISTRO_VER}-${COMP}-package"
          EXAMPLE_DIR="./downloaded-artifact/tt-umd-examples-${DISTRO_VER}-${COMP}-example"

          echo "Install .${PKG_FMT} packages from ${PACKAGE_DIR}"
          DEV_PKG="$(find "${PACKAGE_DIR}" -maxdepth 1 -type f \
            -name "tt_umd-*-Linux-umd-dev.${PKG_FMT}" -print -quit)"
          RUNTIME_PKG="$(find "${PACKAGE_DIR}" -maxdepth 1 -type f \
            -name "tt_umd-*-Linux-umd-runtime.${PKG_FMT}" -print -quit)"
          PYTHON_PKG="$(find "${PY_PACKAGE_DIR}" -maxdepth 1 -type f \
            -name "tt_umd-*-Linux-umd-python.${PKG_FMT}" -print -quit || true)"

          if [ -z "${DEV_PKG}" ] || [ -z "${RUNTIME_PKG}" ]; then
            echo "Required packages not found in ${PACKAGE_DIR}"
            exit 1
          fi

          if [ "${PKG_FMT}" = "deb" ]; then
            apt update
            if [ -n "${PYTHON_PKG}" ]; then
              apt install -y "${DEV_PKG}" "${RUNTIME_PKG}" "${PYTHON_PKG}"
            else
              apt install -y "${DEV_PKG}" "${RUNTIME_PKG}"
            fi
          else
            if [ -n "${PYTHON_PKG}" ]; then
              dnf install -y "${DEV_PKG}" "${RUNTIME_PKG}" "${PYTHON_PKG}"
            else
              dnf install -y "${DEV_PKG}" "${RUNTIME_PKG}"
            fi
          fi

          echo "Copy UMD examples"
          mkdir -p ./example_test
          cp -r ./tt-umd/examples/* ./example_test

          echo "Copy CMake configuration"
          mkdir -p ./cmake
          cp "${EXAMPLE_DIR}"/* ./cmake

          echo "Build UMD examples (which are dependent on libdevice.so)"
          cd ./example_test
          cmake -B build -G Ninja
          cmake --build ./build

          # Sanity check Python import if the package is installed
          if [ "${PKG_FMT}" = "deb" ]; then
            CHECK_CMD="dpkg -s tt_umd-umd-python"
          else
            CHECK_CMD="rpm -q tt_umd-umd-python"
          fi
          if ${CHECK_CMD} >/dev/null 2>&1; then
            echo "Run Python import test for FHS-installed module"
            python3 -c "import tt_umd; print('Python import tt_umd: OK')"
          else
            echo "ERROR: Python package not found! Test skipped improperly."
            exit 1  # Force CI failure
          fi

  build-exalens-kernels:
    name: Build tt-exalens kernels for tests
    timeout-minutes: 5
    runs-on: ubuntu-22.04
    container:
      image: ghcr.io/tenstorrent/tt-exalens/tt-exalens-ci-ubuntu-22.04:latest

    steps:
      - uses: actions/checkout@v4
        with:
          repository: tenstorrent/tt-exalens
          ref: main
          submodules: recursive

      - name: Build test kernels
        run: |
          make

      - name: Remove SFPI from build artifacts
        run: |
          mv build/sfpi build/sfpi_backup
          mkdir -p build/sfpi/compiler/bin/
          cp build/sfpi_backup/compiler/bin/riscv-tt-elf-gdb build/sfpi/compiler/bin/riscv-tt-elf-gdb
          rm -rf build/sfpi_backup
          rm -f build/sfpi_*

      - name: Upload kernels as artifacts
        uses: pyTooling/upload-artifact@v4
        with:
          name: ttexalens-build
          path: |
            build

  run-exalens-tests:
    name: Run tt-exalens tests
    needs:
      - build-manylinux-wheels
      - build-exalens-kernels
    strategy:
      matrix:
        runner-info: [
          {arch: "blackhole", board: "p150b", runs-on: "tt-ubuntu-2204-p150b-stable"},
          {arch: "wormhole_b0", board: "n150", runs-on: "tt-ubuntu-2204-n150-stable"},
          {arch: "wormhole_b0", board: "n300", runs-on: "tt-ubuntu-2204-n300-stable"},
        ]
    runs-on: ${{ matrix.runner-info.runs-on }}
    container:
      image: ghcr.io/tenstorrent/tt-exalens/tt-exalens-ci-ubuntu-22.04:latest
      options: --device /dev/tenstorrent/0
      volumes:
        - /dev/hugepages:/dev/hugepages
        - /dev/hugepages-1G:/dev/hugepages-1G
        - /etc/udev/rules.d:/etc/udev/rules.d
        - /lib/modules:/lib/modules

    steps:
      - uses: actions/checkout@v4
        with:
          repository: tenstorrent/tt-exalens
          ref: main
          submodules: recursive

      - name: Get tt-exalens kernels artifact
        uses: pyTooling/download-artifact@v4
        with:
          name: ttexalens-build

      - name: Get tt-umd wheel artifact
        uses: actions/download-artifact@v4
        with:
          name: manylinux-wheel-artifact

      - name: Install tt-umd wheel
        run: |
          echo "Listing content of current directory before installing the wheel:"
          ls -lAR
          echo "Installing tt-umd wheel..."
          pip install tt_umd-*-cp310*.whl --force-reinstall

      - name: Run Python tests for tt-exalens library
        run: |
          python3 -m unittest discover -v -t . -s test/ttexalens -p *test*.py

      - name: Run Python tests for tt-exalens app
        run: |
          python3 -m unittest discover -v -t . -s test/app -p *test*.py
